#!/bin/bash
# Tiny bash script to run very simple tests.
# https://github.com/RiskoZoSlovenska/sest

NAME='sest'
VERSION='0.8.0'

NL=$'\n'
RUNNER_PYTHON='python3'
RUNNER_C='gcc'
RUNNER_CPP='g++'
TESTS_FAILED_CODE=64

file='tests.txt'
case_delim='==='
input_delim='---'
runner=
needs_compile=false
requested_case=
fail_fast=false
verbose=false
print_output=true
color='auto'


# Just like echo but only does something if verbose is true
function verboseecho() {
	if $verbose; then
		echo "$@"
		return
	fi
}

# Performs cleanup, prints closing messages and exits with an appropriate code.
# Takes one argument: the number of errors encountered.
function finish {
	local msg_color=$green
	local exit_code=0

	if [ "$1" != 0 ]; then
		msg_color=$red
		exit_code=$TESTS_FAILED_CODE
	fi
	echo "${msg_color}$1 failure(s)$normal"

	if [ -f "$compiled_out" ]; then
		verboseecho "${blue}Removing $compiled_out...$normal"
		rm "$compiled_out"
	fi
	echo "${blue}DONE$normal"
	exit $exit_code
}

# $1: name of output array variable
# $2: text
# $3: delimiter
function split_str {
	local -n out=$1; out=()
	local text=$2
	local delim=$3
	local string=$text$delim

	# https://linuxhint.com/bash_split_examples
	while [ "$string" ]; do
		out+=("${string%%"$delim"*}")
		string=${string#*"$delim"}
	done
}

function print_help_and_exit {
	cat <<- EOM
$NAME - Risko's minimal testing utility for competitive(?) programming

Usage: $NAME [OPTIONS...] ARGS... [-- ARGS...]

Available options:
  -h, --help                         Show this help text
      --version                      Show version
  -r, --runner=RUNNER                Interpreter to run the tests with
  -f, --file=FILE                    Read tests from FILE instead of ./$file
  -D, --case-delimiter=CASE_DELIM    Use CASE_DELIM instead of '$case_delim' for
                                       separating cases
  -d, --delimiter=DELIM              Use DELIM instead of '$input_delim' for separating
                                       input/output
  -c, --case=CASE_NUM                Run only one specific test case
  -F, --fast                         Exit immediately on the first test failure
  -v, --verbose                      Be more verbose (mainly when compiling)
  -o, --overview                     Do not print actual or expected test output
      --color=WHEN                   WHEN is 'auto' (def), 'always' or 'never'

Available runners:             Their extensions:          What they are:
  py, python, python3            .py, .py3                  Python ($RUNNER_PYTHON)
  c                              .c                         C ($RUNNER_C)
  c++, cpp                       .cpp, .cc                  C++ ($RUNNER_CPP)

Reads tests from FILE; calls the RUNNER with the given ARGS and test input as
stdin; verifies outputs. Handles compilation if necessary. If no RUNNER is
specified, it is guessed from the extension of the first argument.

FILE should be a normal text file. Cases are separated from each other by
CASE_DELIM, and the input/output of each case is separated by DELIM. Newlines
following delimiters are ignored.

Exits with a special error code of $TESTS_FAILED_CODE if any tests fail.
EOM
	exit
}

function print_version_and_exit {
	echo $VERSION
	exit
}


# Parse arguments (https://stackoverflow.com/a/14203146)
positional_args=()
option_parsing_disabled=false

for i in "$@"; do
	if $option_parsing_disabled; then
		positional_args+=("$i")
		continue
	fi

	case $i in
	-h|--help)
		print_help_and_exit
		;;
	--version)
		print_version_and_exit
		;;
	-r=*|--runner=*)
		runner="${i#*=}"
		case $runner in
			py|python|python3)
				runner=$RUNNER_PYTHON
				;;
			c)
				runner=$RUNNER_C
				needs_compile=true
				;;
			c++|cpp)
				runner=$RUNNER_CPP
				needs_compile=true
				;;
			*)
				runner="${i#*=}"
				;;
		esac
		;;
	-f=*|--file=*)
		file="${i#*=}"
		;;
	-D=*|--case-delimiter=*)
		case_delim="${i#*=}"
		;;
	-d=*|--delimiter=*)
		input_delim="${i#*=}"
		;;
	-c=*|--case=*)
		requested_case="${i#*=}"
		;;
	-F|--fast)
		fail_fast=true
		;;
	-v|--verbose)
		verbose=true
		;;
	-o|--overview)
		print_output=false
		;;
	--color=*)
	    color="${i#*=}"
		;;
	--)
		option_parsing_disabled=true
		;;
	--* | -*)
		echo >&2 "$NAME: unknown option '$i'"
		exit 1
		;;
	*)
		positional_args+=("$i")
		;;
	esac
done

set -- "${positional_args[@]}" # Restore positional parameters


# Set up colors (https://unix.stackexchange.com/a/10065)
# If colors are not requested, the color variables will be empty strings and
# we can still print them safely.
if [ "$color" = always ] || { [ "$color" = auto ] && [ -t 1 ]; }; then
    num_of_colors=$(tput colors)

    if [ "$num_of_colors" ] && [ "$num_of_colors" -ge 8 ]; then # Check if colors are supported
        normal="$(tput sgr0)"
        red="$(tput setaf 1)"
        green="$(tput setaf 2)"
        blue="$(tput setaf 4)" # 6 is cyan which is lighter and may be more pleasing
	fi
fi

# Guess runner
if [ -z "$runner" ]; then
	# https://stackoverflow.com/a/965072
	base=$(basename -- "$1")
	namebody=${base#.} # Don't use leading period for checking if there are periods
	if [ "$namebody" != "${namebody/./}"  ]; then # Parse extension only if there is one
		ext="${base##*.}"
	fi

	case $ext in
		py|py3)
			runner=$RUNNER_PYTHON
			;;
		c)
			runner=$RUNNER_C
			needs_compile=true
			;;
		cpp|cc)
			runner=$RUNNER_CPP
			needs_compile=true
			;;
	esac
fi

# Verify runner
if [ -z "$runner" ]; then
	echo 2>&1 "$NAME: no runner was provided and it couldn't be guessed from args; provide one manually"
	exit 1
elif ! [ -x "$runner" ] && ! command -v "$runner" &>/dev/null; then
	echo 2>&1 "$NAME: cannot use runner '$runner' since it is neither an executable file nor a command"
	exit 1
fi

if [ -x "$runner" ]; then
	runner="./$runner"
fi

echo "${blue}Using runner '$runner'$normal"

if $needs_compile; then
	compiled_out=$(mktemp)
	verboseecho "${blue}Compiling to $compiled_out...$normal"

	if ! compile_msg=$($runner -o "$compiled_out" "$@" 2>&1); then
		echo "${red}Compilation error!$normal"
		echo "$compile_msg"
		finish 1
	else
		verboseecho "$compile_msg"
	fi
fi

# Make sure cases file exists
if ! [ -f "$file" ]; then
	echo >&2 "$NAME: '$file' is not a file"
	exit 1
fi

# Read + split input file
verboseecho "${blue}Reading test cases from $file...$normal"
raw=$(cat "$file" && echo '.')
raw=${raw%.} # https://unix.stackexchange.com/a/10804
declare cases
split_str cases "$raw" "$case_delim$NL"

# Run tests
verboseecho "${blue}Running tests...$normal"
case_num=0
failures_num=0
for case in "${cases[@]}"; do
	((case_num++))

	# Check for a requested case
	if [ "$requested_case" ] && [ "$case_num" != "$requested_case" ]; then
		continue
	fi

	# Split case
	declare parts
	split_str parts "$case" "$input_delim$NL"

	# Check case is formatted correctly
	num_parts=${#parts[@]}
	if [ "$num_parts" != 2 ]; then
		echo >&2 "$NAME: case $case_num is split up into $num_parts section(s), but exactly 2 are expected"
		exit 1
	fi

	input=${parts[0]}
	expected=${parts[1]}

	# Run
	if ! $needs_compile; then
		actual="$($runner "$@" <<< "$input" 2>&1; echo ".$?")"
	else
		actual="$($compiled_out <<< "$input" 2>&1; echo ".$?")"
	fi

	# Extract exit code from output
	runner_exit_code="$(grep -Eo '[0-9]+$' <<< "$actual" | tail -1)" # https://stackoverflow.com/a/44092231 and other replies
	actual="${actual%."$runner_exit_code"}"

	# Handle failure
	if [ "$runner_exit_code" != 0 ]; then
		err_desc="error"
		if [ "$runner_exit_code" -gt 128 ]; then
			err_desc="$(kill -l $(("$runner_exit_code"-128)))"
		fi
		case $err_desc in
			SEGV) err_desc="segmentation fault" ;;
			FPE)  err_desc="floating point exception" ;;
			INT)  err_desc="interrupted" ;;
		esac

		echo "${red}Case $case_num: Runtime error! (code $runner_exit_code: $err_desc)$normal"

		if $print_output; then
			printf "${blue}Output (%d):$normal\n%s\n" ${#actual} "$actual"
		fi

		((failures_num++))
		if $fail_fast; then finish $failures_num; else continue; fi
	fi

	# Check equality
	if [ "$actual" = "$expected" ]; then
		echo "${green}Case $case_num: OK$normal"
	else
		echo "${red}Case $case_num: Wrong output!$normal"

		if $print_output; then
			printf "${blue}Expected (%d):$normal\n%s\n${blue}Got (%d):$normal\n%s\n" \
				${#expected} "$expected" ${#actual} "$actual"
		fi

		((failures_num++))
		if $fail_fast; then finish $failures_num; else continue; fi
	fi
done

finish $failures_num
